use chrono::{DateTime, Utc};
use rss::{ChannelBuilder, EnclosureBuilder, ImageBuilder, ItemBuilder};
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

use crate::network::get_host_ip;

pub fn generate_feeds(root_dir: &str) {
    let root = Path::new(root_dir);

    println!("oxicast using root directory at {}", root.display());

    for entry in fs::read_dir(root).expect("Failed to read root directory") {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.is_dir() {
            // println!("Processing...: {}", path.display());
            generate_show_feed(path.to_str().unwrap());
        } else if path.is_file() {
            // println!("Found file at {}. Skipping", path.display());
        }
    }
}

pub fn generate_show_feed(show_dir: &str) {
    let show_dir = Path::new(show_dir);

    let show_name = show_dir.file_name().unwrap().to_str().unwrap();
    let cover_path = show_dir.join("cover.jpg");
    let cover_url = format!(
        "http://{}:8080/shows/{}/cover.jpg",
        get_host_ip().expect("could not get host ip for cover art"),
        show_name
    );
    let has_cover = cover_path.exists();

    let default_image_url =
        "https://raw.githubusercontent.com/javonharper/oxicast/refs/heads/main/logo.png";

    let image = if has_cover {
        ImageBuilder::default()
            .url(cover_url)
            .title("Show Image")
            .build()
    } else {
        ImageBuilder::default()
            .url(default_image_url)
            .title("Show Image")
            .build()
    };

    let mut channel = ChannelBuilder::default()
        .title(show_name)
        .link("http://www.youtube.com")
        .description("Generated by oxicast")
        .generator(Some("https://github.com/javonharper/oxicast".into()))
        .image(image)
        .build();

    let episodes: Vec<_> = WalkDir::new(show_dir)
        .max_depth(1)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map_or(false, |ext| ext == "m4a"))
        .collect();

    for entry in episodes.iter() {
        let item = create_feed_item(show_name, entry.path().to_str().unwrap());
        channel.items.push(item);
    }

    let rss_path = show_dir.join("feed.xml");

    fs::write(rss_path, channel.to_string()).expect("Failed to write feed");

    println!(
        "http://{}:8080/shows/{}/feed.xml",
        get_host_ip().expect("Could not get ip for host"),
        show_name
    );
}

fn create_feed_item(show_name: &str, episode_path: &str) -> rss::Item {
    let file_size = fs::metadata(episode_path).unwrap().len();
    let file_name_with_extension = episode_path.split('/').last().unwrap();
    let item_title = file_name_with_extension.split('.').next().unwrap();

    let creation_date = fs::metadata(episode_path).unwrap().created().unwrap();
    let datetime: DateTime<Utc> = creation_date.into();

    let local_ip = get_host_ip().expect("Failed to get local IP");

    let enclosure = EnclosureBuilder::default()
        .url(format!(
            "http://{}:8080/shows/{}/{}",
            local_ip, show_name, file_name_with_extension
        ))
        .length(file_size.to_string())
        .build();

    let item = ItemBuilder::default()
        .title(Some(item_title.into()))
        .author(Some(show_name.into()))
        .pub_date(Some(datetime.to_rfc2822()))
        .enclosure(enclosure)
        .build();

    item
}
