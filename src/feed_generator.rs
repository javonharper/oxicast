// use id3::Tag;
use rss::{ChannelBuilder, EnclosureBuilder, ImageBuilder, ItemBuilder};
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

use crate::network::get_host_ip;

pub fn generate_feeds(root_dir: &str) {
    let root = Path::new(root_dir);

    println!("oxicast using root directory at {}", root.display());

    for entry in fs::read_dir(root).expect("Failed to read root directory") {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.is_dir() {
            // println!("Processing...: {}", path.display());
            generate_show_feed(path.to_str().unwrap());
        } else if path.is_file() {
            // println!("Found file at {}. Skipping", path.display());
        }
    }
}

pub fn generate_show_feed(show_dir: &str) {
    let show_dir = Path::new(show_dir);

    let show_name = show_dir.file_name().unwrap().to_str().unwrap();

    // println!(
    //     "Generating feed for show: \"{}\" at {}",
    //     show_name,
    //     show_dir.display()
    // );

    let image = ImageBuilder::default()
        .url("https://raw.githubusercontent.com/javonharper/oxicast/refs/heads/main/logo.png")
        .title("Show Image")
        .build();

    let mut channel = ChannelBuilder::default()
        .title(show_name)
        .link("http://www.youtube.com")
        .description("Generated by oxicast")
        .generator(Some("https://github.com/javonharper/oxicast".into()))
        .image(image)
        .build();

    let episodes: Vec<_> = WalkDir::new(show_dir)
        .max_depth(1)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map_or(false, |ext| ext == "m4a"))
        .collect();

    for entry in episodes.iter() {
        let item = create_feed_item(show_name, entry.path().to_str().unwrap());
        channel.items.push(item);
    }

    let rss_path = show_dir.join("feed.xml");

    fs::write(rss_path, channel.to_string()).expect("Failed to write feed");
    // println!("Generated feed for \"{}\"", show_name);
    println!(
        "http://{}:8080/shows/{}/feed.xml",
        get_host_ip().expect("Could not get ip for host"),
        show_name
    );
}

fn create_feed_item(show_name: &str, episode_path: &str) -> rss::Item {
    let file_name_with_extension = episode_path.split('/').last().unwrap();
    let item_title = file_name_with_extension.split('.').next().unwrap();

    let local_ip = get_host_ip().expect("Failed to get local IP");

    let enclosure = EnclosureBuilder::default()
        .url(format!(
            "{}:8080/shows/{}/{}",
            local_ip, show_name, file_name_with_extension
        ))
        .build();

    let item = ItemBuilder::default()
        .title(Some(item_title.into()))
        .author(Some(show_name.into()))
        .enclosure(enclosure)
        .build();

    item
}
